//Parser.cup
//19/02/2014 - Rohan Kopparapu, Sam Fallahi, David Lipowicz
//Notes - look at type aliasing

import java_cup.runtime.*;

parser code
{:
    public void report_error(String message, Object info) {
    
        StringBuffer err = new StringBuffer("Error in line ");
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol)info;
        err.append((s.left) + ": ");
        System.err.print(err);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:}

action code
{:
:}

//=====================================================================================================================

//Types
terminal        CHAR, BOOL, INT, RAT, FLOAT, DICT, SEQ, TOP, VOID;

//Aggregate operators
terminal        IN, LEN, CONCAT;

//Definitions/Declarations
terminal        TDEF, FDEF;

//Input/Output operators
terminal        READ, PRINT;

// Control flow operators
terminal        IF, ELSE, WHILE, DO, FORALL, RET;

//Logical operators
terminal        NOT, AND, OR, IMPLY;

//Relational operators
terminal        LTHAN, LTHANEQ, EQUALS, NEQUALS /*,MTHAN, MTHANEQ*/;

//Arithmetic operators
terminal        PLUS, MINUS, TIMES, DIV, POW;

//Expression operators
terminal        DOT , ASSIGN;

//Other tokens
terminal        LANGBR, RANGBR, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, LDICT, RDICT, COMMA, COL, SEMICOL, MAIN;

//Loop terminators
terminal        ENDIF, ENDDO;

//Literals
terminal        ID, CHAR_LIT, BOOL_LIT, INT_LIT, FLOAT_LIT, STR_LIT;

//=====================================================================================================================

//Operator precendence
precedence nonassoc     NOT, LTHAN, LTHANEQ, EQUALS, NEQUALS;
precedence right        POW, IN;
precedence left         PLUS, MINUS, TIMES, DIV, AND, CONCAT;

//=====================================================================================================================

//Productions
start with program;

program         ::= glob_decl_list main_func {: System.out.println("Parsing successful."); :}
                  | main_func glob_decl_list {: System.out.println("Parsing successful."); :}
                  | glob_decl_list main_func glob_decl_list {: System.out.println("Parsing successful."); :}
                  | main_func {: System.out.println("Parsing successful."); :}
                  ;

glob_decl_list  ::= glob_decl_list glob_decl
                  | glob_decl
                  ;
glob_decl       ::= var_decl_part
                  | func_def
                  | data_def
                  ;
main_func       ::= VOID MAIN block;

//=====================================================================================================================

type            ::= CHAR | BOOL | INT | RAT | FLOAT | DICT | SEQ | TOP;
literal         ::= CHAR_LIT | BOOL_LIT | INT_LIT | FLOAT_LIT | RAT_LIT | dict_lit | sequence;
sequence        ::= STR_LIT
                  | list_lit
                  ;

accessor        ::= ID
                  | accessor DOT ID
                  ;
                  
list_lit        ::= LBRACK comma_list RBRACK;
comma_list      ::= expr
                  | expr COMMA comma_list
                  |
                  ;
                  
dict_lit        ::= LDICT dict_comma_list RDICT;
dict_comma_list ::= dict_pair
                  | dict_pair COMMA dict_comma_list
                  |
                  ;
dict_pair       ::= literal COL literal;

func_def        ::= DEF type ID LPAR param_list RPAR block;
data_def        ::= TDEF ID COL data_list SEMICOL;
data_list       ::= ID COL type
                  | ID COL type COMMA data_list
                  |
                  ;
                  
param_list      ::= type ID
                  | type ID COMMA param_list
                  |
                  ;

block           ::= LBRACE var_decl_list stat_list RBRACE 
                  | LBRACE stat_list RBRACE
                  | LBRACE RBRACE
                  ;
                  
var_decl_list   ::= var_decl_list var_decl_part
                  | var_decl_part
                  ;
var_decl_part   ::= var_decl SEMICOL;
var_decl        ::= type ID
                  | type assign_stat
                  /* | error assign_stat {: System.err.println("Expected rule 'var_decl'."); :} */
                  | SEQ LANGBR type RANGBR /* seq<type>*/
                  ;

//=====================================================================================================================

//Rules for statements

stat_list       ::= stat_list stat_part
                  | stat_part;
                  
stat_part       ::= stat SEMICOL
                  | if_else
                  | while_do
                  | for_each
                  ;

stat            ::= assign_stat
                  | io_stat
                  | func_call
                  | ret_expr
                  ;
assign_stat     ::= accessor ASSIGN assign_stat
                  | accessor ASSIGN expr_list
                  | elem_access ASSIGN expr
                  ;
io_stat         ::= READ accessor
                  | PRINT expr_list
                  ;
func_call       ::= ID LPAR expr_list RPAR;
if_else         ::= IF LPAR expr RPAR block ELSE block
                  ;
while_do        ::= WHILE LPAR expr RPAR DO block ENDDO;
for_each        ::= FOREACH LPAR ID COL ID RPAR block; //check
ret_expr        ::= RET expr
                  | RET;
elem_access     ::= ID LBRACK expr RBRACK;

len_expr        ::= LEN LPAR ID RPAR;
seq_slice       ::= ID LBRACK INT_LIT COL INT_LIT RBRACK    
                  | ID LBRACK COL INT_LIT RBRACK
                  | ID LBRACK INT_LIT COL RBRACK
                  ;
expr_list       ::= expr
                  | expr COMMA expr_list
                  |
                  ;               

expr            ::= expr TIMES expr
                  | expr PLUS expr
                  | expr MINUS expr
                  | expr DIV expr
                  | expr POW expr
                  | NOT expr
                  | expr AND expr
                  | expr LTHAN expr
                  | expr LTHANEQ expr
                  | expr EQUALS expr
                  | expr NEQUALS expr
                  | expr CONCAT expr
                  | expr IN expr
                  | LPAR expr RPAR
                  | elem_access
                  | func_call
                  | len_expr
                  | seq_slice
                  | accessor
                  | literal
                  ;

