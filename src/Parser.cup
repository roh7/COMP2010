//Parser.cup
//19/02/2014 - Rohan Kopparapu, Sam Fallahi, David Lipowicz
//Notes - look at type aliasing

import java_cup.runtime.*;

parser code
{:
    public void report_error(String message, Object info) {
    
        StringBuffer err = new StringBuffer("Error in line ");
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol)info;
        err.append((s.left) + ": ");
        System.err.print(err);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void syntax_error(Symbol current_token)
    {
        report_error("Syntax error at line " + (current_token.left + 1) +
            ", column " + current_token.right + "\n",  null);
        syntaxErrors = true;
    }

    public boolean syntaxErrors = false;
:}

action code
{:
:}

//=====================================================================================================================

//Types
terminal        CHAR, BOOL, INT, RAT, FLOAT, DICT, SEQ, TOP, VOID;

//Aggregate operators
terminal        IN, LEN, CONCAT;

//Definitions/Declarations
terminal        TDEF, FDEF;

//Input/Output operators
terminal        READ, PRINT;

// Control flow operators
terminal        IF, THEN, ELSE, WHILE, DO, FORALL, RET;

//Logical operators
terminal        NOT, AND, OR, IMPLY;

//Relational operators
terminal        LTHAN, LTHANEQ, EQUALS, NEQUALS /*,MTHAN, MTHANEQ*/;

//Arithmetic operators
terminal        PLUS, MINUS, TIMES, DIV, POW;

//Expression operators
terminal        DOT , ASSIGN;

//Other tokens
terminal        RANGBR, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, /*LDICT, RDICT,*/ COMMA, COL, SEMICOL, MAIN;

//Loop terminators
terminal        ENDIF, ENDDO;

//Literals
terminal        ID, CHAR_LIT, BOOL_LIT, INT_LIT, RAT_LIT, FLOAT_LIT, STR_LIT;

non terminal program, glob_decl_list, glob_decl, main_func, type, aggreg, literal, sequence, accessor;
non terminal list_lit, comma_list, dict_lit, dict_comma_list, dict_pair, func_def, data_def, data_list;
non terminal param_list, block, var_decl_list, var_decl_part, var_decl, stat_list, stat_part, stat;
non terminal assign_stat, io_stat, func_call, if_else, while_do, for_all;
non terminal ret_expr, elem_access, len_expr, seq_slice, expr_list, expr;

//=====================================================================================================================

//Operator precendence
precedence nonassoc     NOT, LTHAN, LTHANEQ, EQUALS, NEQUALS;
precedence right        POW, IN;
precedence left         PLUS, MINUS, TIMES, DIV, AND, CONCAT;

//=====================================================================================================================

//Productions
start with program;

program         ::= glob_decl_list main_func {: System.out.println("Parsing successful."); :}
                  | main_func glob_decl_list {: System.out.println("Parsing successful."); :}
                  | glob_decl_list main_func glob_decl_list {: System.out.println("Parsing successful."); :}
                  | main_func {: System.out.println("Parsing successful."); :}
                  ;

glob_decl_list  ::= glob_decl_list glob_decl
                  | glob_decl
                  ;
glob_decl       ::= var_decl_part
                  | func_def
                  | data_def
                  ;
main_func       ::= VOID MAIN block;

//=====================================================================================================================

type            ::= CHAR | BOOL | INT | RAT | FLOAT | TOP;
aggreg          ::= DICT | SEQ;
literal         ::= CHAR_LIT | BOOL_LIT | INT_LIT | FLOAT_LIT | RAT_LIT | dict_lit | sequence;
sequence        ::= STR_LIT
                  | list_lit
                  ;

accessor        ::= ID
                  | accessor DOT ID
                  ;
                  
list_lit        ::= LBRACK comma_list RBRACK;
comma_list      ::= expr
                  | expr COMMA comma_list
                  |
                  ;
                  
dict_lit        ::= LBRACE dict_comma_list RBRACE;
dict_comma_list ::= dict_pair
                  | dict_pair COMMA dict_comma_list
                  |
                  ;
dict_pair       ::= literal COL literal;

// func_def        ::= FDEF type ID LPAREN param_list RPAREN block;
func_def        ::= FDEF ID LPAREN param_list RPAREN COL type block;
data_def        ::= TDEF ID COL data_list SEMICOL;
data_list       ::= ID COL type
                  | ID COL type COMMA data_list
                  |
                  ;
                  
param_list      ::= type ID
                  | type ID COMMA param_list
                  |
                  ;

block           ::= LBRACE var_decl_list stat_list RBRACE 
                  | LBRACE stat_list RBRACE
                  | LBRACE RBRACE
                  ;
                  
var_decl_list   ::= var_decl_list var_decl_part
                  | var_decl_part
                  ;
var_decl_part   ::= var_decl SEMICOL;
// var_decl        ::= type ID
var_decl        ::= ID COL type
                  // | type assign_stat
                  | assign_stat COL type
                  /* | error assign_stat {: System.err.println("Expected rule 'var_decl'."); :} */
                  | SEQ LTHAN type RANGBR /* seq<type>*/
                  | DICT LTHAN type COMMA type RANGBR /* seq<type,type> */
                  ;

//=====================================================================================================================

//Rules for statements

stat_list       ::= stat_list stat_part
                  | stat_part;
                  
stat_part       ::= stat SEMICOL
                  | if_else
                  | while_do
                  | for_all
                  ;

stat            ::= assign_stat
                  | io_stat
                  | func_call
                  | ret_expr
                  ;
assign_stat     ::= accessor ASSIGN assign_stat
                  | accessor ASSIGN expr_list
                  | elem_access ASSIGN expr
                  ;
io_stat         ::= READ accessor
                  | PRINT expr_list
                  ;
func_call       ::= ID LPAREN expr_list RPAREN;
if_else         ::= IF LPAREN expr RPAREN THEN var_decl_list stat_list ELSE var_decl_list stat_list ENDIF
                  | IF LPAREN expr RPAREN THEN var_decl_list stat_list ENDIF
                  ;
// while_do        ::= WHILE LPAREN expr RPAREN DO block ENDDO; //check
while_do        ::= WHILE LPAREN expr RPAREN DO var_decl_list stat_list ENDDO
                  | WHILE LPAREN expr RPAREN DO stat_list ENDDO
                  ;

// for_all         ::= FORALL LPAREN ID COL ID RPAREN block; //check
for_all         ::= FORALL LPAREN ID IN ID RPAREN DO var_decl_list stat_list ENDDO
                  | FORALL LPAREN ID IN ID RPAREN DO stat_list ENDDO
                  ;


ret_expr        ::= RET expr
                  | RET;
elem_access     ::= ID LBRACK expr RBRACK;

len_expr        ::= LEN LPAREN ID RPAREN;
seq_slice       ::= ID LBRACK INT_LIT COL INT_LIT RBRACK    
                  | ID LBRACK COL INT_LIT RBRACK
                  | ID LBRACK INT_LIT COL RBRACK
                  ;
expr_list       ::= expr
                  | expr COMMA expr_list
                  |
                  ;               

expr            ::= expr TIMES expr //needs an OR used somewhere and IMPLIES
                  | expr PLUS expr
                  | expr MINUS expr
                  | expr DIV expr
                  | expr POW expr
                  | NOT expr
                  | expr AND expr
                  | expr LTHAN expr
                  | expr LTHANEQ expr
                  | expr EQUALS expr
                  | expr NEQUALS expr
                  | expr CONCAT expr
                  | expr IN expr
                  | LPAREN expr RPAREN
                  | elem_access
                  | func_call
                  | len_expr
                  | seq_slice
                  | accessor
                  | literal
                  ;

